# Writing a pipeline to upgrade an existing VMware Tanzu Operations Manager

This how-to-guide shows you how to create a pipeline for upgrading an existing Vmware Tanzu Operations Manager VM.
If you don't have a Tanzu Operations Manager VM, see [Installing Tanzu Operations Manager](./installing-opsman.md).

<%= partial "getting-started" %>

## Exporting the installation

Before upgrading Tanzu Operations Manager,
you must first download and persist
an export of the current installation.

<p class="note caution">
<span class="note__title">Caution</span>
VMware <b><em>strongly recommends</em></b> automatically exporting
the Tanzu Operations Manager installation
and <b><em>persisting it to your blobstore</em></b> on a regular basis.
This ensures that if you need to upgrade (or restore)
your Tanzu Operations Manager for any reason,
you'll have the latest installation info available.
A time trigger is added later in this tutorial
to help with this.</p>

1. First, switch out the test job
for one that downloads and installs Tanzu Operations Manager.
Do this by changing:

   - the `name` of the job
   - the `name` of the task
   - the `file` of the task

    The first task in the job should be [`download-product`](../tasks.md#download-product).
    It has an additional required input;
    the `config` file `download-product` uses to talk to Tanzu Network.

1. Before writing that file and making it available as a resource,
`get` it (and reference it in the params)
as if it's there.

    It also has an additional output (the downloaded image).
    It will be used in a subsequent step,
    so you don't have to `put` it anywhere.

1. Finally, while it's fine for `test` to run in parallel,
the install process shouldn't, so
you also need to add `serial: true` to the job.

    ```yaml hl_lines="2 3 15-21"
    jobs:
    - name: export-installation
      serial: true
      plan:
        - get: platform-automation-image
          resource: platform-automation
          params:
            globs: ["*image*.tgz"]
            unpack: true
        - get: platform-automation-tasks
          resource: platform-automation
          params:
            globs: ["*tasks*.zip"]
            unpack: true
        - get: env
        - task: export-installation
          image: platform-automation-image
          file: platform-automation-tasks/tasks/export-installation.yml
        - put: installation
          params:
            file: installation/installation-*.zip
    ```


      1. If you try to `fly` this up to Concourse,
      it will again throw errors about resources that don't exist,
      so the next step is to make them.
      The first new resource you need is the config file.
      2. Push your git repo to a remote on GitHub
      to make this (and later, other) configuration available to the pipelines.
      GitHub has good [instructions](https://docs.github.com/en/migrations/importing-source-code/using-the-command-line-to-import-source-code/adding-locally-hosted-code-to-github)
      you can follow to create a new repository on GitHub.
      You can skip over the part
      about using `git init` to set up your repo,
      since you did that earlier.

1. Now set up your remote
and use `git push` to make it available.
You will use this repository to hold our single foundation specific configuration.
These instructions use the ["Single repository for each Foundation"](../pipeline-design/configuration-management-strategies.md#single-foundation-pattern)
pattern to structure the configurations.

1. Add the repository URL to CredHub so that you can reference it
later when you declare the corresponding resource.

    ```yaml
    pipeline-repo: git@github.com:username/your-repo-name
    ```

1. Write an `env.yml` for your Tanzu Operations Manager.

    `env.yml` holds authentication and target information
    for a particular Tanzu Operations Manager.

    An example `env.yml` for username/password authentication
    is shown below with the required properties.
    Please reference [Configuring Env](./configuring-env.md) for the entire list of properties
    that can be used with `env.yml`
    as well as an example of an `env.yml`
    that can be used with UAA (SAML, LDAP, etc.) authentication.

    The property `decryption-passphrase` is required for `import-installation`,
    and therefore required for `upgrade-opsman`.

    If your foundation uses authentication other than basic auth,
    see [Inputs and Outputs](../inputs-outputs.md)
    for more detail on UAA-based authentication.


    ```yaml
    target: ((opsman-url))
    username: ((opsman-username))
    password: ((opsman-password))
    decryption-passphrase: ((opsman-decryption-passphrase))
    ```

1. Add and commit the new `env.yml` file:

    ```bash
    git add env.yml
    git commit -m "Add environment file for foundation"
    git push
    ```

2. Now that the env file is in your git remote,
you can add a resource to tell Concourse how to get it as `env`.

    Since this is (probably) a private repo,
    you must create a deploy key Concourse can use to access it.
    Follow the [GitHub instructions](https://docs.github.com/en/authentication/connecting-to-github-with-ssh/managing-deploy-keys#deploy-keys)
    for creating a deploy key.

1. Place the private key in CredHub so you can use it in your pipeline:

    ```bash
    # note the starting space
    credhub set \
      --name /concourse/your-team-name/plat-auto-pipes-deploy-key \
      --type ssh \
      --private the/filepath/of/the/key-id_rsa \
      --public the/filepath/of/the/key-id_rsa.pub
    ```

2. Add this to the resources section of your pipeline file:

    ```yaml
    - name: env
      type: git
      source:
        uri: ((pipeline-repo))
        private_key: ((plat-auto-pipes-deploy-key.private_key))
        branch: main
    ```

3. Put the credentials in CredHub:

    ```bash
    # note the starting space throughout
    credhub set \
      -n /concourse/your-team-name/foundation/opsman-username \
      -t value -v your-opsman-username
    credhub set \
      -n /concourse/your-team-name/foundation/opsman-password \
      -t value -v your-opsman-password
    credhub set \
      -n /concourse/your-team-name/foundation/opsman-decryption-passphrase \
      -t value -v your-opsman-decryption-passphrase
    ```

    <%= partial "./paths-and-pipeline-names" %>

1. To perform interpolation in one of your input files,
you need the [`credhub-interpolate` task](../tasks.md#credhub-interpolate)
Earlier, you relied on Concourse's native integration with CredHub for interpolation.
That worked because you needed to use the variable
in the pipeline itself, not in one of your inputs.

    You can add it to your job
    after retrieving your `env` input,
    but before the `export-installation` task:

    ```yaml hl_lines="16-26"
    jobs:
    - name: export-installation
      serial: true
      plan:
        - get: platform-automation-image
          resource: platform-automation
          params:
            globs: ["*image*.tgz"]
            unpack: true
        - get: platform-automation-tasks
          resource: platform-automation
          params:
            globs: ["*tasks*.zip"]
            unpack: true
        - get: env
        - task: credhub-interpolate
          image: platform-automation-image
          file: platform-automation-tasks/tasks/credhub-interpolate.yml
          params:
            CREDHUB_CLIENT: ((credhub-client))
            CREDHUB_SECRET: ((credhub-secret))
            CREDHUB_SERVER: https://your-credhub.example.com
            PREFIX: /concourse/your-team-name/foundation
          input_mapping:
            files: env
          output_mapping:
            interpolated-files: interpolated-env
        - task: export-installation
          image: platform-automation-image
          file: platform-automation-tasks/tasks/export-installation.yml
          input_mapping:
            env: interpolated-env
        - put: installation
          params:
            file: installation/installation-*.zip
    ```

    <p class="note">
    <span class="note__title">Note</span>
    The <code>credhub-interpolate</code> task for this job
    maps the output from the task (<code>interpolated-files</code>)
    to <code>interpolated-env</code>.
    This can be used by the next task in the job
    to more explicitly define the inputs/outputs of each task.
    It is also okay to leave the output as <code>interpolated-files</code>
    if it is appropriately referenced in the next task.</p>

    Notice the [input mappings](https://concourse-ci.org/jobs.html#schema.step.task-step.input_mapping)
    of the `credhub-interpolate` and `export-installation` tasks.
    This allows you to use the output of one task
    as in input of another.

    An alternative to `input_mappings` is discussed in
    [Configuration Management Strategies](../pipeline-design/configuration-management-strategies.md#advanced-pipeline-design).

1. Put your `credhub_client` and `credhub_secret` into CredHub,
so Concourse's native integration can retrieve them
and pass them as configuration to the `credhub-interpolate` task.

    ```bash
    # note the starting space throughout
    credhub set \
            -n /concourse/your-team-name/credhub-client \
            -t value -v your-credhub-client
    credhub set \
            -n /concourse/your-team-name/credhub-secret \
            -t value -v your-credhub-secret
    ```

    Now, the `credhub-interpolate` task
    will interpolate our config input,
    and pass it to `export-installation` as `config`.

1. The other new resource you need is a blobstore,
so you can persist the exported installation.

    Add an [S3 resource](https://github.com/concourse/s3-resource)
    to the `resources` section:

    ```yaml
    - name: installation
      type: s3
      source:
        access_key_id: ((s3-access-key-id))
        secret_access_key: ((s3-secret-key))
        bucket: ((platform-automation-bucket))
        regexp: installation-(.*).zip
    ```

1. Save the credentials in CredHub:

    ```bash
    # note the starting space throughout
    credhub set \
            -n /concourse/your-team-name/s3-access-key-id \
            -t value -v your-bucket-s3-access-key-id
    credhub set \
            -n /concourse/your-team-name/s3-secret-key \
            -t value -v your-s3-secret-key
    ```

1. This time (and in the future),
when you set the pipeline with `fly`,
you need to load vars from `vars.yml`.

    ```bash
    # note the space before the command
    fly -t control-plane set-pipeline \
        -p foundation \
        -c pipeline.yml \
        -l vars.yml
    ```

1. Manually trigger a build. This time, it should pass.

    <p class="note important">
    <span class="note__title">Important</span>
    You'll be using this,
    the ultimate form of the <code>fly</code> command to set your pipeline,
    for the rest of the tutorial.
    <br>
    You can save yourself some typing by using your bash history
    (if you did not prepend your command with a space).
    You can cycle through previous commands with the up and down arrows.
    Alternatively,
    Ctrl-r will search your bash history.
    Holding Ctrl-r, type <code>fly</code>,
    and you will see the last fly command you ran.
    Run it with enter, or
    instead of running it,
    use Ctrl-r again
    to see the matching command before that.</p>

1. This is a good commit point:

    ```bash
    git add pipeline.yml vars.yml
    git commit -m "Export foundation installation in CI"
    git push
    ```

## Performing the upgrade

Now that you have an exported installation,
it's time to create another Concourse job to do the upgrade itself.
The export and the upgrade need to be in separate jobs
so they can be triggered (and re-run) independently.

This new job uses the [`upgrade-opsman`](../tasks.md#upgrade-opsman) task.

1. Write a new job that has `get` steps
for your platform-automation resources
and all the inputs you already know how to get:

    ```yaml
    - name: upgrade-opsman
      serial: true
      plan:
      - get: platform-automation-image
        resource: platform-automation
          params:
          globs: ["*image*.tgz"]
          unpack: true
      - get: platform-automation-tasks
        resource: platform-automation
        params:
          globs: ["*tasks*.zip"]
          unpack: true
      - get: env
      - get: installation
    ```

2. Do a commit here. The job doesn't do anything useful yet, but
it's a good place to start.

    ```bash
    git add pipeline.yml
    git commit -m "Set up initial gets for upgrade job"
    git push
    ```

    <p class="note important">
    <span class="note__title">Important</span>
    We recommend frequent, small commits that can be <code>fly</code> set and,
    ideally, go green.
    <br>
    This one doesn't actually do anything though, right?
    Fair, but: setting and running the job
    gives you feedback on your syntax and variable usage.
    It can catch typos, resources you forgot to add or misnamed, and so on.
    Committing when you get to a working point helps keeps the diffs small,
    and the history tractable.
    Also, down the line, if you've got more than one pair working on a foundation,
    the small commits help you keep off one another's toes.
    <br>
    This workflow is not demonstrated here,
    but it can even be useful to make a commit,
    use <code>fly</code> to see if it works,
    and then push it if and only if it works.
    If it doesn't, you can use <code>git commit --amend</code>
    once you've figured out why and fixed it.
    This workflow makes it easy to keep what is set on Concourse
    and what is pushed to your source control remote in sync.</p>

1. You need the three required inputs for [`upgrade-opsman`](..//tasks.md#upgrade-opsman).

      * `state`
      * `config`
      * `image`

    There are optional inputs, vars used with the config,
    and you can add those when you do `config`.

2. Start with the [state file](../inputs-outputs.md#state).
Record the `iaas` your're using and the ID of the _currently deployed_ Tanzu Operations Manager VM.
Different IaaS uniquely identify VMs differently;
here are examples for what this file should look like,
depending on your IaaS:

    **AWS**

    <%= partial "../examples/state/aws" %>

    **Azure**

    <%= partial "../examples/state/azure" %>

    **GCP**

    <%= partial "../examples/state/gcp" %>

    **OpenStack**

    <%= partial "../examples/state/openstack" %>

    **vSphere**

    <%= partial "../examples/state/vsphere" %>

1. Choose the IaaS you need for your IaaS,
write it in your repo as `state.yml`,
commit it, and push it:

    ```bash
    git add state.yml
    git commit -m "Add state file for foundation Ops Manager"
    git push
    ```

    You can map the `env` resource to the [`upgrade-opsman`](..//tasks.md#upgrade-opsman)
    `state` input after you add the task.

    But first, there are two more inputs to arrange for.

1. Option 1: Write a [Tanzu Operations Manager VM Configuration file](../inputs-outputs.md#opsman-config)
to `opsman.yml`.
The properties available vary by IaaS,
but you can often inspect your existing Tanzu Operations Manager
in your IaaS console
(or, if your Tanzu Operations Manager was created with Terraform,
look at your Terraform outputs)
to find the necessary values.

    <ul>
      <li><strong>AWS</strong><%= partial "../examples/opsman-config/aws1" %></li>
      <li><strong>Azure</strong><%= partial "../examples/opsman-config/azure1" %></li>
      <li><strong>GCP</strong><%= partial "../examples/opsman-config/gcp1" %></li>
      <li><strong>OpenStack</strong><%= partial "../examples/opsman-config/openstack1" %></li>
      <li><strong>vSphere</strong><%= partial "../examples/opsman-config/vsphere1" %></li>
    </ul>

1. Option 2: Alternatively, you can auto-generate your opsman.yml
using a `p-automator` command to output an opsman.yml file
in the directory it is called from.

    **AWS**

      ```bash
        docker run -it --rm -v $PWD:/workspace -w /workspace platform-automation-image \
          p-automator export-opsman-config \
          --state-file generated-state/state.yml \
          --config-file opsman.yml \
          --aws-region "$AWS_REGION" \
          --aws-secret-access-key "$AWS_SECRET_ACCESS_KEY" \
          --aws-access-key-id "$AWS_ACCESS_KEY_ID"
      ```

    **Azure**

      ```bash
        docker run -it --rm -v $PWD:/workspace -w /workspace platform-automation-image \
          p-automator export-opsman-config \
          --state-file generated-state/state.yml \
          --config-file opsman.yml \
          --azure-subscription-id "$AZURE_SUBSCRIPTION_ID" \
          --azure-tenant-id "$AZURE_TENANT_ID" \
          --azure-client-id "$AZURE_CLIENT_ID" \
          --azure-client-secret "$AZURE_CLIENT_SECRET" \
          --azure-resource-group "$AZURE_RESOURCE_GROUP"
      ```

    **GCP**

      ```bash
        docker run -it --rm -v $PWD:/workspace -w /workspace platform-automation-image \
          p-automator export-opsman-config \
          --state-file generated-state/state.yml \
          --config-file opsman.yml \
          --gcp-zone "$GCP_ZONE" \
          --gcp-service-account-json <(echo "$GCP_SERVICE_ACCOUNT_JSON") \
          --gcp-project-id "$GCP_PROJECT_ID"
      ```

    **vSphere**

      ```bash
        docker run -it --rm -v $PWD:/workspace -w /workspace platform-automation-image \
          p-automator export-opsman-config \
          --state-file generated-state/state.yml \
          --config-file opsman.yml \
          --vsphere-url "$VCENTER_URL" \
          --vsphere-username "$VCENTER_USERNAME" \
          --vsphere-password "$VCENTER_PASSWORD"
      ```

1. Once you have your config file, commit and push it:

    ```bash
    git add opsman.yml
    git commit -m "Add opsman config"
    git push
    ```

2. Get the image for the new Tanzu Operations Manager version using the [`download-product`](../tasks.md#download-product) task.
It requires a config file to specify which Tanzu Operations Manager to get,
and to provide Tanzu Network credentials.
Name this file `download-opsman.yml`:

    ```yaml
    ---
    pivnet-api-token: ((pivnet-refresh-token)) # interpolated from CredHub
    pivnet-file-glob: "ops-manager*.ova"
    pivnet-product-slug: ops-manager
    product-version-regex: ^2\.5\.0.*$
    ```

    ```bash
    git add download-opsman.yml
    git commit -m "Add download opsman config"
    git push
    ```

1. Now put it all together using the following:

    ```yaml hl_lines="16-46"
    - name: upgrade-opsman
      serial: true
      plan:
      - get: platform-automation-image
        resource: platform-automation
        params:
          globs: ["*image*.tgz"]
          unpack: true
      - get: platform-automation-tasks
        resource: platform-automation
        params:
          globs: ["*tasks*.zip"]
          unpack: true
      - get: env
      - get: installation
      - task: credhub-interpolate
        image: platform-automation-image
        file: platform-automation-tasks/tasks/credhub-interpolate.yml
        params:
          CREDHUB_CLIENT: ((credhub-client))
          CREDHUB_SECRET: ((credhub-secret))
          CREDHUB_SERVER: ((credhub-server))
          PREFIX: /concourse/your-team-name/foundation
        input_mapping:
          files: env
        output_mapping:
          interpolated-files: interpolated-configs
      - task: download-opsman-image
        image: platform-automation-image
        file: platform-automation-tasks/tasks/download-product.yml
        params:
          CONFIG_FILE: download-opsman.yml
        input_mapping:
          config: interpolated-configs
      - task: upgrade-opsman
        image: platform-automation-image
        file: platform-automation-tasks/tasks/upgrade-opsman.yml
        input_mapping:
          config: interpolated-configs
          image: downloaded-product
          secrets: interpolated-configs
          state: env
    ```

    <p class="note">
    <span class="note__title">Note</span>
    We do not explicitly set the default parameters
    for <code>upgrade-opsman</code> in this example.
    Because <code>opsman.yml</code> is the default input to <code>OPSMAN_CONFIG_FILE</code>,
    <code>env.yml</code> is the default input to <code>ENV_FILE</code>,
    and <code>state.yml</code> is the default input to <code>STATE_FILE</code>,
    it is redundant to set this param in the pipeline.
    See the <a href="../tasks.md">task definitions</a>
    for a full range of the
    available and default parameters.</p>

2. Set the pipeline.

    Before running the job,
    [`ensure`](https://concourse-ci.org/jobs.html#schema.step.ensure) that `state.yml` is always persisted
    regardless of whether the `upgrade-opsman` job failed or passed.
    Add the following section to the job:

    ```yaml hl_lines="49-68"
    - name: upgrade-opsman
      serial: true
      plan:
      - get: platform-automation-image
        resource: platform-automation
        params:
          globs: ["*image*.tgz"]
          unpack: true
      - get: platform-automation-tasks
        resource: platform-automation
        params:
          globs: ["*tasks*.zip"]
          unpack: true
      - get: env
      - get: installation
      - task: credhub-interpolate
        image: platform-automation-image
        file: platform-automation-tasks/tasks/credhub-interpolate.yml
        params:
          CREDHUB_CLIENT: ((credhub-client))
          CREDHUB_SECRET: ((credhub-secret))
          CREDHUB_SERVER: ((credhub-server))
          PREFIX: /concourse/your-team-name/foundation
        input_mapping:
          files: env
        output_mapping:
          interpolated-files: interpolated-configs
      - task: download-opsman-image
        image: platform-automation-image
        file: platform-automation-tasks/tasks/download-product.yml
        params:
          CONFIG_FILE: download-opsman.yml
        input_mapping:
          config: interpolated-configs
      - task: upgrade-opsman
        image: platform-automation-image
        file: platform-automation-tasks/tasks/upgrade-opsman.yml
        input_mapping:
          config: interpolated-configs
          image: downloaded-product
          secrets: interpolated-configs
          state: env
      ensure:
        do:
        - task: make-commit
          image: platform-automation-image
          file: platform-automation-tasks/tasks/make-git-commit.yml
          input_mapping:
            repository: env
            file-source: generated-state
          output_mapping:
            repository-commit: env-commit
          params:
            FILE_SOURCE_PATH: state.yml
            FILE_DESTINATION_PATH: state.yml
            GIT_AUTHOR_EMAIL: "ci-user@example.com"
            GIT_AUTHOR_NAME: "CI User"
            COMMIT_MESSAGE: 'Update state file'
        - put: env
          params:
            repository: env-commit
            merge: true
    ```

3. Set the pipeline one final time,
run the job, and see it pass.

    ```bash
    git add pipeline.yml
    git commit -m "Upgrade Ops Manager in CI"
    git push
    ```

Your upgrade pipeline is now complete.
